package main

import (
	"bytes"
	"fmt"
	"log"
	"math"
	"slices"
	"strings"
	"time"
	"unsafe"

	"github.com/diamondburned/aoc-2022/aocutil"
)

func main() {
	aocutil.Run(part1, part2)
}

type SpringCondition byte

const (
	Operational SpringCondition = '.'
	Damaged     SpringCondition = '#'
	Unknown     SpringCondition = '?'
)

func (c SpringCondition) String() string {
	switch c {
	case Operational:
	case Damaged:
	case Unknown:
	default:
		return fmt.Sprintf("SpringCondition(%c)", c)
	}
	return string(c)
}

type SpringConditions []SpringCondition

func (s SpringConditions) String() string {
	return string(s)
}

func (s SpringConditions) UnknownIndexes() []int {
	unknownIndexes := make([]int, 0, len(s))
	for i, c := range s {
		if c == Unknown {
			unknownIndexes = append(unknownIndexes, i)
		}
	}
	return unknownIndexes
}

// DamagedGroups returns a list of groups of damaged or unknown springs.
// For example, "###.###" will return [[###], [###]].
func (s SpringConditions) DamagedGroups() []SpringConditions {
	b := unsafe.Slice((*byte)(unsafe.Pointer(&s[0])), len(s))
	groups := bytes.Split(b, []byte{byte(Operational)})
	groups = aocutil.FilterInplace(groups, func(s []byte) bool { return len(s) != 0 })
	return unsafe.Slice((*SpringConditions)(unsafe.Pointer(unsafe.SliceData(groups))), len(groups))
}

type SpringRow struct {
	Conditions SpringConditions
	// DamagedRuns describes runs of damaged springs. A group of [1, 1, 3]
	// may look like '#....#.###'.
	DamagedRuns []int
}

func parseInput(input string) []SpringRow {
	lines := aocutil.SplitLines(input)
	conditions := make([]SpringRow, 0, len(lines))
	for _, line := range lines {
		s1, s2, _ := strings.Cut(line, " ")
		conditions = append(conditions, SpringRow{
			Conditions:  []SpringCondition(s1),
			DamagedRuns: aocutil.Atois[int](strings.Split(s2, ",")),
		})
	}
	return conditions
}

// Unfold returns a copy of the SpringRow with the conditions unfolded n times.
func (r SpringRow) Unfold(n int) SpringRow {
	// Unfolding 0 times means returning the original row.
	// Unfolding 1 time means returning it repeated twice.
	n++

	new := r
	new.Conditions = SpringConditions(strings.Repeat(string(r.Conditions)+"?", n))
	new.Conditions = new.Conditions[:len(new.Conditions)-1]
	new.DamagedRuns = make([]int, len(r.DamagedRuns)*n)
	for i := 0; i < n; i++ {
		copy(new.DamagedRuns[i*len(r.DamagedRuns):], r.DamagedRuns)
	}
	return new
}

// allPossibleSpringConditions returns an iterator that iterates through all
// possible spring conditions. A spring condition that is unknown will be
// iterated through as both damaged and operational.
func allPossibleSpringConditions(conditions SpringConditions, k int) func(yield func(springs SpringConditions, k int) bool) bool {
	unknownIndexes := conditions.UnknownIndexes()

	allOperational := slices.Clone(conditions)
	for _, i := range unknownIndexes {
		allOperational[i] = Operational
	}

	buffer := make([]SpringCondition, len(conditions))

	return func(yield func(SpringConditions, int) bool) bool {
		doK := func(k int) bool {
			allDamaged := aocutil.AllCombinations(unknownIndexes, k)
			if !allDamaged(func(damaged []int) bool {
				copy(buffer, allOperational)
				for _, i := range damaged {
					buffer[i] = Damaged
				}
				return yield(buffer, k)
			}) {
				return false
			}
			return true
		}
		if k != -1 {
			return doK(k)
		}
		for k := 0; k <= len(unknownIndexes); k++ {
			if !doK(k) {
				return false
			}
		}
		return true
	}
}

// isValidConditionGroup returns whether the given condition group is valid.
// It uses the given damaged runs to check whether the group is valid.
// It assumes that there is no unknown condition in the group.
func isValidConditionGroup(conditions SpringConditions, damagedRuns []int) bool {
	damagedGroups := conditions.DamagedGroups()
	if len(damagedGroups) != len(damagedRuns) {
		return false
	}

	for i, group := range damagedGroups {
		run := damagedRuns[i]
		if len(group) != run {
			return false
		}
	}

	return true
}

func totalValidSpringConditions(springs SpringRow, kHint int) (total int, k int) {
	usedK := -1
	each := allPossibleSpringConditions(springs.Conditions, kHint)
	each(func(conditions SpringConditions, k int) bool {
		if !isValidConditionGroup(conditions, springs.DamagedRuns) {
			return !(usedK != -1 && k > usedK)
		}
		if usedK != -1 && usedK != k {
			panic("assumption failed")
		}
		usedK = k
		total++
		return true
	})
	return total, usedK
}

func part1(input string) int {
	return -1

	rows := parseInput(input)

	var total int
	for _, springs := range rows {
		t, _ := totalValidSpringConditions(springs, -1)
		total += t
	}

	return total
}

func part2(input string) int {
	rows := parseInput(input)

	totalCh := make(chan int)
	inputCh := make(chan SpringRow)

	for i := 0; i < 1; i++ {
		go func() {
			for row := range inputCh {
				validConditions := make(map[string]bool)
				// Figure out total for unfold(n=0) and unfold(n=1).
				now := time.Now()
				var total1 int
				usedK := -1
				each1 := allPossibleSpringConditions(row.Conditions, -1)
				each1(func(conditions SpringConditions, k int) bool {
					if !isValidConditionGroup(conditions, row.DamagedRuns) {
						return !(usedK != -1 && k > usedK)
					}
					if usedK != -1 && usedK != k {
						panic("assumption failed")
					}
					usedK = k
					total1++
					validConditions[string(conditions)] = true
					return true
				})
				log.Printf("total1 (%d) took %s with k = %d\n", total1, time.Since(now), usedK)

				now = time.Now()

				unfolded := row.Unfold(1)
				// unfoldedMidpoint := len(unfolded.Conditions) / 2

				// secondHalf := string(unfolded.Conditions[unfoldedMidpoint+1:])
				// var total2 int
				// for firstHalf := range validConditions {
				// 	considering := SpringConditions(firstHalf + "?" + secondHalf)
				// 	// log.Println(unfolded.Conditions, unfolded.DamagedRuns)
				// 	// log.Println(considering)
				// 	each2 := allPossibleSpringConditions(considering, usedK)
				// 	each2(func(conditions SpringConditions, k int) bool {
				// 		if !isValidConditionGroup(conditions, unfolded.DamagedRuns) {
				// 			return true
				// 		}
				// 		total2++
				// 		return true
				// 	})
				// }
				// log.Println("total2", total2)

				var total2 int
				each2 := allPossibleSpringConditions(unfolded.Conditions, usedK*2)
				each2(func(conditions SpringConditions, k int) bool {
					if !isValidConditionGroup(conditions, unfolded.DamagedRuns) {
						return true
					}
					total2++
					return true
				})
				log.Printf("total2 (%d) took %s with k = %d\n", total2, time.Since(now), usedK*2)

				// Calculate the multiplier.
				multiplier := total2 / total1
				// Correlate.
				total5 := total1 * int(math.Pow(float64(multiplier), 4))
				totalCh <- total5
				log.Printf("%s: %d", row.Conditions, total5)
			}
		}()
	}

	go func() {
		for _, row := range rows {
			inputCh <- row
		}
		close(inputCh)
	}()

	var total int
	for range rows {
		total += <-totalCh
	}

	return total
}
